### For my ordinal model exploration, I will use Queens
code <- nimbleCode({
beta1 ~ dnorm(0, sd = 200)
beta2 ~ dnorm(0, sd = 200)
tau ~ dunif(0,100)
sigma <- 1
alpha3 ~ dnorm(0,3)
alpha4 ~ dnorm(0,3)
gam[1] <- -9999999
gam[2] <- 20
gam[3] <- exp(alpha3)
gam[4] <- exp(alpha4) + gam[3]
gam[5] <- 9999999
for(i in 1:n){
mu[i] <- beta1 * t[i] * ((tau-i) + abs(tau-i)) / (2 * (tau-i)) +
beta2 * t[i] * ((i-tau) + abs(i-tau)) / (2 * (i-tau))
z[i,] ~ dmulti(psi[i,1:4], size=1)
for(j in 1:4){
psi[i,j] <- iprobit((gam[j+1]-mu[i])/sigma) - iprobit((gam[j]-mu[i])/sigma)
}
}
})
# Setting Values
n <- dim(queens)[1]
y <- queens$new_cases_per_100k
queens$category <- rep(0, n)
for (i in 1:n) {
if (y[i] < 50) {
queens$category[i] = 1
}
else if (y[i] < 200) {
queens$category[i] = 2
}
else if (y[i] < 400) {
queens$category[i] = 3
}
else {
queens$category[i] = 4
}
}
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
t <- 1:n
z <- sample(queens$category)
z2 <- matrix(0, nrow=n, ncol=4)
for(i in 1:n){
z2[i,z[i]] <- 1
}
constants <- list(n = n, t = t, mu_zero = mu_zero)
data <- list(z = z2)
gaminit <- c(-10000, 20, exp(5), exp(6),  50000)
betainit <- c(solve(t(t)%*%t)%*%t(t)%*%y)
inits <- list(beta1 = betainit, beta2 = betainit, tau = 50.1, sigma=2, alpha3 = 0, alpha4 = 1)
model <- nimbleModel(code, constants = constants, data = data, inits = inits)
# Compile Model, run MCMC
cmodel = compileNimble(model)
mcmc.out <- nimbleMCMC(code = code, constants = constants,
data = data, inits = inits, nburnin=2000,
nchains = 1, niter = 10000,thin=2,
summary = TRUE,
monitors = c('beta1', "beta2", "alpha3","alpha4", "tau"),
samplesAsCodaMCMC = TRUE,
WAIC = TRUE)
# Model Summary
mcmc.out$summary
iprobit(-9999999 - 2)
iprobit(20)
0 - 1
dmulti(z2[1, ], prob = c(.1, .1, .1, -.1), size = 1)
iprobit((20 - 2)) - iprobit(-9999999 - 2)
iprobit((exp(5) - 2)) - iprobit(20 - 2)
iprobit((exp(6) - 2)) - iprobit(exp(5) - 2)
iprobit(999999 - 2)) - iprobit(exp(6) - 2)
iprobit(999999 - 2)) - iprobit(exp(6) - 2))
iprobit(999999 - 2) - iprobit(exp(6) - 2))
iprobit(999999 - 2) - iprobit(exp(6) - 2)
iprobit((20 - 2)) - iprobit(-9999999 - 2)
iprobit((exp(5) - 2)) - iprobit(20 - 2)
iprobit((exp(6) - 2)) - iprobit(exp(5) - 2)
iprobit(999999 - 2) - iprobit(exp(6) - 2)
dmulti(z2[1, ], size = 1, prob = c(1, 0, 0, 0))
exp(1)
iprobit(-10)
z2
200 * 1
iprobit((20 - 200)) - iprobit(-9999999 - 200)
iprobit((exp(5) - 200)) - iprobit(20 - 200)
iprobit((exp(6) - 200)) - iprobit(exp(5) - 200)
iprobit(999999 - 200) - iprobit(exp(6) - 200)
dmulti(z2[1, ], prob = c(0, 0, 1, 0))
z2[1,]
z2[2,]
dmulti(z2[2, ], prob = c(0, 0, 1, 0))
curve(dgamma(x, .1, .1))
curve(dgamma(x, .1, 10))
curve(dgamma(x, 10, .1))
curve(dgamma(x, 10, .1), from = 0, to = 100)
iprobit((20 - 200) / 100) - iprobit((-9999999 - 200) / 100))
iprobit((20 - 200) / 100) - iprobit((-9999999 - 200) / 100)
## Get 6 counties data ready to be modeled
initial_data <- read.csv("US_COVID_weekly_NY_data.csv")
covid_data <- initial_data[,c(5,11,23)]
albany <- covid_data[covid_data$id=='ID1903',]
queens <- covid_data[covid_data$id=='ID1944',]
newyork <- covid_data[covid_data$id=='ID1933',]
bronx <- covid_data[covid_data$id=='ID1905',]
wyoming <- covid_data[covid_data$id=='ID1965',]
niagara <- covid_data[covid_data$id=='ID1934',]
covidlist <- list(albany, queens, newyork, bronx, wyoming, niagara)
### For my ordinal model exploration, I will use Queens
code <- nimbleCode({
beta1 ~ dnorm(0, sd = 200)
beta2 ~ dnorm(0, sd = 200)
tau ~ dunif(0,100)
sigma ~ dgamma(10, 0.1)
alpha3 ~ dnorm(0,3)
alpha4 ~ dnorm(0,3)
gam[1] <- 0
gam[2] <- 20
gam[3] <- exp(alpha3)
gam[4] <- exp(alpha4) + gam[3]
gam[5] <- 9999999
for(i in 1:n){
mu[i] <- beta1 * t[i] * ((tau-i) + abs(tau-i)) / (2 * (tau-i)) +
beta2 * t[i] * ((i-tau) + abs(i-tau)) / (2 * (i-tau))
z[i,] ~ dmulti(psi[i,1:4], size=1)
for(j in 1:4){
psi[i,j] <- iprobit((gam[j+1]-mu[i])/sigma) - iprobit((gam[j]-mu[i])/sigma)
}
}
})
iprobit((20 - 200) / 100) - iprobit((-9999999 - 200) / 100)
iprobit((exp(5) - 200)) - iprobit(20 - 200)
iprobit((exp(6) - 200)) - iprobit(exp(5) - 200)
iprobit(999999 - 200) - iprobit(exp(6) - 200)
# Setting Values
n <- dim(queens)[1]
y <- queens$new_cases_per_100k
queens$category <- rep(0, n)
for (i in 1:n) {
if (y[i] < 50) {
queens$category[i] = 1
}
else if (y[i] < 200) {
queens$category[i] = 2
}
else if (y[i] < 400) {
queens$category[i] = 3
}
else {
queens$category[i] = 4
}
}
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
t <- 1:n
z <- sample(queens$category)
z2 <- matrix(0, nrow=n, ncol=4)
for(i in 1:n){
z2[i,z[i]] <- 1
}
constants <- list(n = n, t = t, mu_zero = mu_zero)
data <- list(z = z2)
gaminit <- c(0, 20, exp(5), exp(6),  50000)
betainit <- c(solve(t(t)%*%t)%*%t(t)%*%y)
inits <- list(beta1 = betainit, beta2 = betainit, tau = 50.1, sigma=2, alpha3 = 0, alpha4 = 1)
model <- nimbleModel(code, constants = constants, data = data, inits = inits)
# Compile Model, run MCMC
cmodel = compileNimble(model)
mcmc.out <- nimbleMCMC(code = code, constants = constants,
data = data, inits = inits, nburnin=2000,
nchains = 1, niter = 10000,thin=2,
summary = TRUE,
monitors = c('beta1', "beta2", "alpha3","alpha4", "tau"),
samplesAsCodaMCMC = TRUE,
WAIC = TRUE)
z2
z <- queens$category
z2 <- matrix(0, nrow=n, ncol=4)
for(i in 1:n){
z2[i,z[i]] <- 1
}
z2
n <- 100 #number of times
# Can loop through all of this if you want to simulate values for multiple locations
x <- runif(n)-0.5 # covariate (centered at 0)
distmat <- as.matrix(dist(1:n)) # distance in time
x <- sort(x)
x
y <- mvrnorm(1, beta1*x[1:50], diag(50))
y2 <- mvrnorm(1, beta2*x[51:100], diag(50))
y <- c(y,y2)
beta1 <- 2 #slope
beta2 <- 8
y <- mvrnorm(1, beta1*x[1:50], diag(50))
y2 <- mvrnorm(1, beta2*x[51:100], diag(50))
y <- c(y,y2)
y
z <- rep(0, 100)
z
for(i in 1:100){
if(y[i]< -1){
z[i] <- 1
}
else if(y[i] < -0){
z[i] <- 2
}
else if(y[i] < 1.1) {
z[i] <- 3
}
else{
z[i] <- 4
}
}
z
betainit <- c(solve(t(x1)%*%x1)%*%t(x1)%*%y1)
betainit
# Setting Values
n <- dim(queens)[1]
y <- queens$new_cases_per_100k
queens$category <- rep(0, n)
for (i in 1:n) {
if (y[i] < 50) {
queens$category[i] = 1
}
else if (y[i] < 200) {
queens$category[i] = 2
}
else if (y[i] < 400) {
queens$category[i] = 3
}
else {
queens$category[i] = 4
}
}
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
t <- 1:n
z <- queens$category
z2 <- matrix(0, nrow=n, ncol=4)
y
z2
for(i in 1:n){
z2[i,z[i]] <- 1
}
z2
betainit <- c(solve(t(t)%*%t)%*%t(t)%*%y)
betainit
betainit
2.35 * 1
exp(2)
## Get 6 counties data ready to be modeled
initial_data <- read.csv("US_COVID_weekly_NY_data.csv")
covid_data <- initial_data[,c(5,11,23)]
albany <- covid_data[covid_data$id=='ID1903',]
queens <- covid_data[covid_data$id=='ID1944',]
newyork <- covid_data[covid_data$id=='ID1933',]
bronx <- covid_data[covid_data$id=='ID1905',]
wyoming <- covid_data[covid_data$id=='ID1965',]
niagara <- covid_data[covid_data$id=='ID1934',]
covidlist <- list(albany, queens, newyork, bronx, wyoming, niagara)
### For my ordinal model exploration, I will use Queens
code <- nimbleCode({
beta1 ~ dnorm(0, sd = 200)
beta2 ~ dnorm(0, sd = 200)
tau ~ dunif(0,100)
sigma ~ dgamma(10, 0.1)
alpha3 ~ dnorm(0,3)
alpha4 ~ dnorm(0,3)
gam[1] <- 0
gam[2] <- 20
gam[3] <- exp(alpha3) + gam[2]
gam[4] <- exp(alpha4) + gam[3]
gam[5] <- gam[4] + 10000
for(i in 1:n){
mu[i] <- beta1 * t[i] * ((tau-i) + abs(tau-i)) / (2 * (tau-i)) +
beta2 * t[i] * ((i-tau) + abs(i-tau)) / (2 * (i-tau))
z[i,] ~ dmulti(psi[i,1:4], size=1)
for(j in 1:4){
psi[i,j] <- iprobit((gam[j+1]-mu[i])/sigma) - iprobit((gam[j]-mu[i])/sigma)
}
}
})
iprobit((20 - 200) / 100) - iprobit((-9999999 - 200) / 100)
iprobit((exp(5) - 200)) - iprobit(20 - 200)
iprobit((exp(6) - 200)) - iprobit(exp(5) - 200)
iprobit(999999 - 200) - iprobit(exp(6) - 200)
# Setting Values
n <- dim(queens)[1]
y <- queens$new_cases_per_100k
queens$category <- rep(0, n)
for (i in 1:n) {
if (y[i] < 50) {
queens$category[i] = 1
}
else if (y[i] < 200) {
queens$category[i] = 2
}
else if (y[i] < 400) {
queens$category[i] = 3
}
else {
queens$category[i] = 4
}
}
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
t <- 1:n
z <- queens$category
z2 <- matrix(0, nrow=n, ncol=4)
for(i in 1:n){
z2[i,z[i]] <- 1
}
constants <- list(n = n, t = t, mu_zero = mu_zero)
data <- list(z = z2)
gaminit <- c(0, 20, exp(5), exp(6),  50000)
betainit <- c(solve(t(t)%*%t)%*%t(t)%*%y)
inits <- list(beta1 = betainit, beta2 = betainit, tau = 50.1, sigma=2, alpha3 = 0, alpha4 = 1)
model <- nimbleModel(code, constants = constants, data = data, inits = inits)
# Compile Model, run MCMC
cmodel = compileNimble(model)
mcmc.out <- nimbleMCMC(code = code, constants = constants,
data = data, inits = inits, nburnin=2000,
nchains = 1, niter = 10000,thin=2,
summary = TRUE,
monitors = c('beta1', "beta2", "alpha3","alpha4", "tau"),
samplesAsCodaMCMC = TRUE,
WAIC = TRUE)
# Model Summary
mcmc.out$summary
z2
## Get 6 counties data ready to be modeled
initial_data <- read.csv("US_COVID_weekly_NY_data.csv")
covid_data <- initial_data[,c(5,11,23)]
albany <- covid_data[covid_data$id=='ID1903',]
queens <- covid_data[covid_data$id=='ID1944',]
newyork <- covid_data[covid_data$id=='ID1933',]
bronx <- covid_data[covid_data$id=='ID1905',]
wyoming <- covid_data[covid_data$id=='ID1965',]
niagara <- covid_data[covid_data$id=='ID1934',]
covidlist <- list(albany, queens, newyork, bronx, wyoming, niagara)
### For my ordinal model exploration, I will use Queens
code <- nimbleCode({
beta1 ~ dnorm(0, sd = 200)
beta2 ~ dnorm(0, sd = 200)
tau ~ dunif(0,100)
sigma ~ dgamma(10, 0.1)
alpha3 ~ dnorm(0,3)
alpha4 ~ dnorm(0,3)
gam[1] <- 0
gam[2] <- 20
gam[3] <- exp(alpha3) + gam[2]
gam[4] <- exp(alpha4) + gam[3]
gam[5] <- gam[4] + 10000
for(i in 1:n){
mu[i] <- beta1 * t[i] * ((tau-i) + abs(tau-i)) / (2 * (tau-i)) +
beta2 * t[i] * ((i-tau) + abs(i-tau)) / (2 * (i-tau))
z[i,] ~ dmulti(psi[i,1:4], size=1)
for(j in 1:4){
psi[i,j] <- iprobit((gam[j+1]-mu[i])/sigma) - iprobit((gam[j]-mu[i])/sigma)
}
}
})
iprobit((20 - 200) / 100) - iprobit((-9999999 - 200) / 100)
iprobit((exp(5) - 200)) - iprobit(20 - 200)
iprobit((exp(6) - 200)) - iprobit(exp(5) - 200)
iprobit(999999 - 200) - iprobit(exp(6) - 200)
# Setting Values
n <- dim(queens)[1]
y <- queens$new_cases_per_100k
queens$category <- rep(0, n)
for (i in 1:n) {
if (y[i] < 50) {
queens$category[i] = 1
}
else if (y[i] < 200) {
queens$category[i] = 2
}
else if (y[i] < 400) {
queens$category[i] = 3
}
else {
queens$category[i] = 4
}
}
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
t <- 1:n
z <- queens$category
z2 <- matrix(0, nrow=n, ncol=4)
for(i in 1:n){
z2[i,z[i]] <- 1
}
constants <- list(n = n,  mu_zero = mu_zero)
data <- list(z = z2, t = t)
gaminit <- c(0, 20, exp(5), exp(6),  50000)
betainit <- c(solve(t(t)%*%t)%*%t(t)%*%y)
inits <- list(beta1 = betainit, beta2 = betainit, tau = 50.1, sigma=2, alpha3 = 0, alpha4 = 1)
model <- nimbleModel(code, constants = constants, data = data, inits = inits)
# Compile Model, run MCMC
cmodel = compileNimble(model)
mcmc.out <- nimbleMCMC(code = code, constants = constants,
data = data, inits = inits, nburnin=2000,
nchains = 1, niter = 10000,thin=2,
summary = TRUE,
monitors = c('beta1', "beta2", "alpha3","alpha4", "tau"),
samplesAsCodaMCMC = TRUE,
WAIC = TRUE)
# Model Summary
mcmc.out$summary
iprobit(0)
exp(2)
## Get 6 counties data ready to be modeled
initial_data <- read.csv("US_COVID_weekly_NY_data.csv")
covid_data <- initial_data[,c(5,11,23)]
albany <- covid_data[covid_data$id=='ID1903',]
queens <- covid_data[covid_data$id=='ID1944',]
newyork <- covid_data[covid_data$id=='ID1933',]
bronx <- covid_data[covid_data$id=='ID1905',]
wyoming <- covid_data[covid_data$id=='ID1965',]
niagara <- covid_data[covid_data$id=='ID1934',]
covidlist <- list(albany, queens, newyork, bronx, wyoming, niagara)
### For my ordinal model exploration, I will use Queens
code <- nimbleCode({
beta1 ~ dnorm(0, sd = 200)
beta2 ~ dnorm(0, sd = 200)
tau ~ dunif(0,100)
sigma ~ dgamma(10, 0.1)
alpha3 ~ dnorm(0,3)
alpha4 ~ dnorm(0,3)
gam[1] <- 0
gam[2] <- 20
gam[3] <- exp(alpha3) + gam[2]
gam[4] <- exp(alpha4) + gam[3]
gam[5] <- gam[4] + 10000
for(i in 1:n){
mu[i] <- beta1 * t[i] * ((tau-i) + abs(tau-i)) / (2 * (tau-i)) +
beta2 * t[i] * ((i-tau) + abs(i-tau)) / (2 * (i-tau))
z[i,] ~ dmulti(psi[i,1:4], size=1)
for(j in 1:4){
psi[i,j] <- iprobit((gam[j+1]-mu[i])/sigma) - iprobit((gam[j]-mu[i])/sigma)
}
}
})
iprobit((20 - 200) / 100) - iprobit((-9999999 - 200) / 100)
iprobit((exp(5) - 200)) - iprobit(20 - 200)
iprobit((exp(6) - 200)) - iprobit(exp(5) - 200)
iprobit(999999 - 200) - iprobit(exp(6) - 200)
# Setting Values
n <- dim(queens)[1]
y <- queens$new_cases_per_100k
queens$category <- rep(0, n)
for (i in 1:n) {
if (y[i] < 50) {
queens$category[i] = 1
}
else if (y[i] < 200) {
queens$category[i] = 2
}
else if (y[i] < 400) {
queens$category[i] = 3
}
else {
queens$category[i] = 4
}
}
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
t <- 1:n
z <- queens$category
z2 <- matrix(0, nrow=n, ncol=4)
for(i in 1:n){
z2[i,z[i]] <- 1
}
constants <- list(n = n,  mu_zero = mu_zero)
data <- list(z = z2, t = t)
gaminit <- c(0, 20, exp(5), exp(6),  50000)
betainit <- c(solve(t(t)%*%t)%*%t(t)%*%y)
inits <- list(beta1 = betainit, beta2 = betainit, tau = 10.1, sigma=2, alpha3 = 3, alpha4 = 4)
model <- nimbleModel(code, constants = constants, data = data, inits = inits)
# Compile Model, run MCMC
cmodel = compileNimble(model)
mcmc.out <- nimbleMCMC(code = code, constants = constants,
data = data, inits = inits, nburnin=2000,
nchains = 1, niter = 10000,thin=2,
summary = TRUE,
monitors = c('beta1', "beta2", "alpha3","alpha4", "tau"),
samplesAsCodaMCMC = TRUE,
WAIC = TRUE)
# Model Summary
mcmc.out$summary
iprobit(1) - iprobit(2)
iprobit(4) - iprobit(3)
iprobit(0) - iprobit(-1)
iprobit(1000)
dmulti(z2[1, ], prob = c(0, 0, 0, -1))
dmulti(z2[1, ], prob = c(0, 0, 0, 0))
dmulti(z2[1, ], prob = c(0, 0, 0, 1))
z
z[66:97]
z[11:12]
plot(t, z)
plot(y, z)
n <- 100 #number of times
# Can loop through all of this if you want to simulate values for multiple locations
x <- runif(n)-0.5 # covariate (centered at 0)
distmat <- as.matrix(dist(1:n)) # distance in time
x <- sort(x)
beta1 <- 2 #slope
beta2 <- 8
y <- mvrnorm(1, beta1*x[1:50], diag(50))
y2 <- mvrnorm(1, beta2*x[51:100], diag(50))
