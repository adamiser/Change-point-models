plot_usmap(data=df, values="ChangePoint_Ord", include="New York") + scale_fill_continuous(name="Change Point") +
theme(legend.position='right') +
ggtitle("Mean Change Points Mapped Across NY")
#map of the range of the 95% CI bounds
range_ord_nyplot <- plot_usmap(data=df, values="ChangePointRange_Ord", include="New York") + scale_fill_continuous(name="Change Point") +
theme(legend.position='right') +
ggtitle("95% CI Range of Change Point - Ordinal Response")
#Maps of change points and 95% CI bounds for continuous response model
range_cont_nyplot <- plot_usmap(data=df, values="ChangePointRange_Cont", include="New York") + scale_fill_continuous(name="Change Point") +
theme(legend.position='right') +
ggtitle("95% CI Range of Change Point - Continuous Response")
grid.arrange(range_ord_nyplot, range_cont_nyplot, ncol = 2)
### OBSERVATIONS ###
# It seems that the ordinal response actually predicted the change point with less
# variability than the continuous model. This may just show that the ordinal model is
# better than the continuous model?
### To consider the question: How are beta's behaving before and after change point?
# 2 maps: posterior mean of the beta's for death before the change and beta's for death after change
beta1death_ord_nyplot <- plot_usmap(data=df, values="Beta1death_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 100)) +
theme(legend.position='right') +
ggtitle("Beta1death - Ordinal Response")
beta2death_ord_nyplot <- plot_usmap(data=df, values="Beta2death_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 100)) +
theme(legend.position='right') +
ggtitle("Beta2death - Ordinal Response")
grid.arrange(beta1death_ord_nyplot, beta2death_ord_nyplot, ncol = 2)
### OBSERVATIONS ###
# The range of coefficient values across the counties is quite large. Most coefficients are small,
# but others are huge. This makes the plot of NY look rather boring.
# I've adjusted the limits to try and make it more interesting (I don't know that it's
# the best approach). It seems that the coefficients tend to be larger after the change point.
# 2 maps: beta's for vaccination instead of death
beta1vax_ord_nyplot <- plot_usmap(data=df, values="Beta1vax_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 100)) +
theme(legend.position='right') +
ggtitle("Beta1vax - Ordinal Response")
beta2vax_ord_nyplot <- plot_usmap(data=df, values="Beta2vax_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 1000)) +
theme(legend.position='right') +
ggtitle("Beta2vax - Ordinal Response")
grid.arrange(beta1vax_ord_nyplot, beta2vax_ord_nyplot, ncol = 2)
### OBSERVATIONS ###
# These look better than the death coefficient. It's clear that the coefficient dramatically
# increases after the change point - this makes sense because vaccinations likely cause
# the change point, or at least the change point occurs around when vaccinations
# began to reach the public.
# conisder the ranges of credible intervals
remove_outlier <- df[-c(2,33,48,52,60),]
beta1deathRange_ord_nyplot <- plot_usmap(data=remove_outlier, values="Beta1deathRange_Ord", include="New York") + scale_fill_continuous(name="Beta1death") +
theme(legend.position='right') +
ggtitle("95% CI Range of Beta1death - Ordinal Response")
beta2deathRange_ord_nyplot <- plot_usmap(data=remove_outlier, values="Beta2deathRange_Ord", include="New York") + scale_fill_continuous(name="Beta2death") +
theme(legend.position='right') +
ggtitle("95% CI Range of Beta2death - Ordinal Response")
grid.arrange(beta1death_nyplot, beta2death_nyplot, ncol = 2)
### OBSERVATIONS ###
# I removed a few outliers that seemed to be disrupting the plots.
# Map the ranges for the beta's for the continuous response model (I expect the range to be a lot smaller)
# Map of population
df$logpop <- log(populations)
plot_usmap(data=df, values="logpop", include="New York") + scale_fill_continuous(name="log pop") +
theme(legend.position='right') +
ggtitle("Log Population Mapped Across NY")
### IGNORE FOR NOW
# Plots of weekly ordinal data with change points marked?
ii <- 1 #for(ii in 1:n.counties){
thiscounty <- subset(dat, Recip_County==counties[ii])
plot(thiscounty$category, type='l', xlab="Week", ylab="Category", ylim=c(1, 4), main=counties[ii])
abline(v=tausave[ii,1], col='darkgray')
abline(v=tausave[ii,2:3], lty=2, col='darkgray') #I didn't look to see what these were but assumed they were bounds on the CI?
#}
### TEST ###
# 2 maps: posterior mean of the beta's for death before the change and beta's for death after change
df$logbeta1death_ord <- (df$Beta1death_Ord)^2
df$logbeta2death_ord <- log(df$Beta2death_Ord)^2
beta1death_ord_nyplot <- plot_usmap(data=df, values="logbeta1death_Ord", include="New York") +
scale_fill_continuous(name="Change Point") +
theme(legend.position='right') +
ggtitle("Beta1death - Ordinal Response")
beta2death_ord_nyplot <- plot_usmap(data=df, values="logbeta2death_Ord", include="New York") +
scale_fill_continuous(name="Change Point") +
theme(legend.position='right') +
ggtitle("Beta2death - Ordinal Response")
grid.arrange(beta1death_ord_nyplot, beta2death_ord_nyplot, ncol = 2)
beta1death_ord_nyplot <- plot_usmap(data=df, values="Beta1death_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 1000)) +
theme(legend.position='right') +
ggtitle("Beta1death - Ordinal Response")
beta2death_ord_nyplot <- plot_usmap(data=df, values="Beta2death_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 1000)) +
theme(legend.position='right') +
ggtitle("Beta2death - Ordinal Response")
grid.arrange(beta1death_ord_nyplot, beta2death_ord_nyplot, ncol = 2)
beta1death_ord_nyplot <- plot_usmap(data=df, values="Beta1death_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 100)) +
theme(legend.position='right') +
ggtitle("Beta1death - Ordinal Response")
beta2death_ord_nyplot <- plot_usmap(data=df, values="Beta2death_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 100)) +
theme(legend.position='right') +
ggtitle("Beta2death - Ordinal Response")
grid.arrange(beta1death_ord_nyplot, beta2death_ord_nyplot, ncol = 2)
beta1vax_ord_nyplot <- plot_usmap(data=df, values="Beta1vax_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 100)) +
theme(legend.position='right') +
ggtitle("Beta1vax - Ordinal Response")
beta2vax_ord_nyplot <- plot_usmap(data=df, values="Beta2vax_Ord", include="New York") +
scale_fill_continuous(name="Change Point",
limits = c(0, 1000)) +
theme(legend.position='right') +
ggtitle("Beta2vax - Ordinal Response")
grid.arrange(beta1vax_ord_nyplot, beta2vax_ord_nyplot, ncol = 2)
# Map of change points
plot_usmap(data=df, values="ChangePoint_Ord", include="New York") + scale_fill_continuous(name="Change Point") +
theme(legend.position='right') +
ggtitle("Mean Change Points Mapped Across NY")
df$logpop <- log(populations)
plot_usmap(data=df, values="logpop", include="New York") + scale_fill_continuous(name="log pop") +
theme(legend.position='right') +
ggtitle("Log Population Mapped Across NY")
df$Beta2vax_Ord
gelman
library(tidyverse)
library(nimble)
library(coda)
#Load the data
dat <- read.csv("currentjoineddata.csv")
counties <- unique(dat$Recip_County)
n.counties <- length(counties)
tausave <- matrix(0, ncol=6, nrow=n.counties)
beta1deathsave <- matrix(0, ncol=6, nrow = n.counties)
beta2deathsave <- matrix(0, ncol=6, nrow = n.counties)
beta1vaxsave <- matrix(0, ncol=6, nrow = n.counties)
beta2vaxsave <- matrix(0, ncol=6, nrow = n.counties)
phiUsave <- matrix(0, ncol=6, nrow = n.counties)
phiVsave <- matrix(0, ncol=6, nrow = n.counties)
phiWsave <- matrix(0, ncol=6, nrow = n.counties)
sigmasave <- matrix(0, ncol=6, nrow=n.counties)
gamma3save <- matrix(0, ncol=6, nrow=n.counties)
gamma4save <- matrix(0, ncol=6, nrow=n.counties)
waic <- matrix(0, ncol = 2, nrow = n.counties)
gelman <- vector('list', length = n.counties)
jj <- 1
thiscounty <- counties[jj]
#Select just one county
this <- dat %>%
subset(Recip_County==thiscounty) %>%
select(Date, category, prev_log_new_death, Administered_Dose1_Pop_Pct.x, log_new_death,
new_vax_this_week, new_cases_per_100k)
###############
# Create data for Nimble Model
# Note: Using rev() bc data appear to be in reverse time order so I'm putting them back in chronological order
z <- rev(this$category)
x1 <- rev(this$prev_log_new_death)
x2 <- rev(this$Administered_Dose1_Pop_Pct.x)
x2[1] <- 0 #no new vaccinations before the first date
n <- length(z)
y <- rev(this$new_cases_per_100k)
###############
#Nimble Ordinal Model
codeOrd <- nimbleCode({
beta1death ~ dnorm(0, sd = 200)
beta2death ~ dnorm(0, sd = 200)
beta1vax ~ dnorm(0, sd = 200)
beta2vax ~ dnorm(0, sd = 200)
tau ~ dunif(5,n-5)
sigma ~ dgamma(1, .1)
alpha3 ~ dnorm(0,1)
alpha4 ~ dnorm(0,1)
gam[1] <- -9999999
gam[2] <- 0
gam[3] <- exp(alpha3)
gam[4] <- exp(alpha4) + gam[3]
gam[5] <- 9999999
phiU ~ dunif(0,20)
phiW ~ dunif(0,20)
phiV ~ dunif(0,20)
cholU[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiU))
U[1:n] ~ dmnorm(mu_zero[1:n], cholesky = cholU[1:n,1:n], prec_param = 1)
cholW[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiW))
cholV[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiV))
W[1:n] ~ dmnorm(mu_zero[1:n], cholesky=cholW[1:n,1:n], prec_param=1)
V[1:n] ~ dmnorm(mu_zero[1:n], cholesky=cholV[1:n,1:n], prec_param=1)
beta1deathstar <- beta1death / sigma
beta2deathstar <- beta2death / sigma
beta1vaxstar <- beta1vax / sigma
beta2vaxstar <- beta2vax / sigma
for(i in 1:n){
mu[i] <- U[i] + (beta1death * x1[i] + beta1vax*x2[i] + V[i]) * ((tau-i) + abs(tau-i)) / (2 * (tau-i)) +
(beta2death * x1[i] +beta2vax*x2[i] + W[i])* ((i-tau) + abs(i-tau)) / (2 * (i-tau))
z[i,] ~ dmulti(psi[i,1:4], size=1)
for(j in 1:4){
psi[i,j] <- iprobit((gam[j+1]-mu[i])/sigma) - iprobit((gam[j]-mu[i])/sigma)
}
}
})
#Setting Values
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
z2 <- matrix(0, nrow=n, ncol=4)
for(i in 1:n){
z2[i,z[i]] <- 1
}
constantsOrd <- list(n = n, x1 = x1,x2=x2, mu_zero = mu_zero)
dataOrd <- list(z = z2, distmat=distmat)
gaminit <- c(-2, 0, exp(0), exp(1) + exp(0),  5)
y1 <- runif(length(z), min=gaminit[z], max=gaminit[z+1])
xmat <- cbind(x1, x2)
betainit <- c(solve(t(xmat)%*%xmat)%*%t(xmat)%*%y1)
initsOrd <- list(beta1death = betainit[1], beta2death = betainit[1],
beta1vax=betainit[2], beta2vax=betainit[2], tau = n/2+.1,
sigma=1, alpha3 = 0, alpha4 = 1, phiU=1, phiW=1, phiV=1, U=mu_zero,
W=mu_zero, V=mu_zero)
modelOrd <- nimbleModel(codeOrd, constants = constantsOrd, data = dataOrd, inits = initsOrd)
#Compile Model, run MCMC
cmodelOrd = compileNimble(modelOrd)
mcmc.outOrd <- nimbleMCMC(code = codeOrd, constants = constantsOrd,
data = dataOrd, inits = initsOrd, nburnin=5000,
nchains = 2, niter = 100000,thin=5,
summary = TRUE,
monitors = c('beta1death', "beta2death", "beta1vax", "beta2vax",
"alpha3","alpha4", "tau", "phiU", "phiV", "phiW", "sigma",
"beta1deathstar", "beta2deathstar",
"beta1vaxstar", "beta2vaxstar",
"gam"),
samplesAsCodaMCMC = TRUE,
WAIC = TRUE)
#Model Summary
#mcmc.outOrd$summary
tausave[jj,1:3] <- mcmc.outOrd$summary$all.chains[15,c(1,4,5)]
beta1deathsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[4, c(1, 4, 5)]
beta2deathsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[8, c(1, 4, 5)]
beta1vaxsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[6, c(1, 4, 5)]
beta2vaxsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[10, c(1, 4, 5)]
phiUsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[11, c(1, 4, 5)]
phiVsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[12, c(1, 4, 5)]
phiWsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[13, c(1, 4, 5)]
sigmasave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[14, c(1, 4, 5)]
waic[jj, 1] <- mcmc.outOrd$WAIC$WAIC
gelman[[jj]][[1]] <- gelman.diag(mcmc.outOrd$samples)
###############################
# Compare the change point when we estimate with continuous response
codeCont <- nimbleCode({
beta1death ~ dnorm(0, sd = 200)
beta2death ~ dnorm(0, sd = 200)
beta1vax ~ dnorm(0, sd = 200)
beta2vax ~ dnorm(0, sd = 200)
tau ~ dunif(5,n-5)
sigma ~ dgamma(1, .1)
phiU ~ dunif(0,20)
phiW ~ dunif(0,20)
phiV ~ dunif(0,20)
cholU[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiU))
U[1:n] ~ dmnorm(mu_zero[1:n], cholesky = cholU[1:n,1:n], prec_param = 1)
cholW[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiW))
cholV[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiV))
W[1:n] ~ dmnorm(mu_zero[1:n], cholesky=cholW[1:n,1:n], prec_param=1)
V[1:n] ~ dmnorm(mu_zero[1:n], cholesky=cholV[1:n,1:n], prec_param=1)
for(i in 1:n){
mu[i] <- U[i] + (beta1death * x1[i] + beta1vax*x2[i] + V[i]) * ((tau-i) + abs(tau-i)) / (2 * (tau-i)) +
(beta2death * x1[i] +beta2vax*x2[i] + W[i])* ((i-tau) + abs(i-tau)) / (2 * (i-tau))
y[i] ~ dnorm(mu[i], sigma)
}
})
# Setting Values
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
constantsCont <- list(n = n, x1 = x1,x2=x2, mu_zero = mu_zero)
dataCont <- list(y = y, distmat=distmat)
xmat <- cbind(x1, x2)
betainit <- c(solve(t(xmat)%*%xmat)%*%t(xmat)%*%y)
initsCont <- list(beta1death = betainit[1], beta2death = betainit[1],
beta1vax=betainit[2], beta2vax=betainit[2], tau = n/2+.1,
sigma=1, phiU=1, phiW=1, phiV=1, U=mu_zero,
W=mu_zero, V=mu_zero)
modelCont <- nimbleModel(codeCont, constants = constantsCont, data = dataCont, inits = initsCont)
# Compile Model, run MCMC
cmodelCont = compileNimble(modelCont)
mcmc.outCont <- nimbleMCMC(code = codeCont, constants = constantsCont,
data = dataCont, inits = initsCont, nburnin=5000,
nchains = 2, niter = 100000,thin=5,
summary = TRUE,
monitors = c('beta1death', "beta2death", "beta1vax", "beta2vax",
"tau", "phiU", "phiV", "phiW", "sigma"),
samplesAsCodaMCMC = TRUE,
WAIC = TRUE)
# Model Summary
#mcmc.outCont$summary
tausave[jj,4:6] <- mcmc.outCont$summary$all.chains[9,c(1,4,5)]
beta1deathsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[1, c(1, 4, 5)]
beta2deathsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[3, c(1, 4, 5)]
beta1vaxsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[2, c(1, 4, 5)]
beta2vaxsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[4, c(1, 4, 5)]
phiUsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[5, c(1, 4, 5)]
phiVsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[6, c(1, 4, 5)]
phiWsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[7, c(1, 4, 5)]
sigmasave[jj, 4:6] <- mcmc.outCont$summary$all.chains[8, c(1, 4, 5)]
waic[jj, 2] <- mcmc.outCont$WAIC$WAIC
gelman[[jj]][[2]] <- gelman.diag(mcmc.outCont$samples)
print(paste("Finished:", jj))
mcmc.outCont$summary
mcmc.outOrd$summary
mcmc.outOrd$summary$all.chains[14, c(1, 4, 5)]
mcmc.outOrd$samples
gelman.diag(mcmc.outOrd$samples)
gelman.diag(mcmc.outOrd$samples)
raftery.diag(mcmc.outOrd$samples)
raftery[[jj]][[1]] <- raftery.diag(mcmc.outOrd$samples)
raftery <- vector('list', length = n.counties)
raftery <- vector('list', length = n.counties)
raftery[[jj]][[1]] <- raftery.diag(mcmc.outOrd$samples)
raftery
gelman.diag(mcmc.outCont$samples)
gelman.disg(mcmc.outOrd$samples)
gelman.diag(mcmc.outOrd$samples)
library(tidyverse)
library(nimble)
library(coda)
#Load the data
dat <- read.csv("currentjoineddata.csv")
counties <- unique(dat$Recip_County)
n.counties <- length(counties)
tausave <- matrix(0, ncol=6, nrow=n.counties)
beta1deathsave <- matrix(0, ncol=6, nrow = n.counties)
beta2deathsave <- matrix(0, ncol=6, nrow = n.counties)
beta1vaxsave <- matrix(0, ncol=6, nrow = n.counties)
beta2vaxsave <- matrix(0, ncol=6, nrow = n.counties)
phiUsave <- matrix(0, ncol=6, nrow = n.counties)
phiVsave <- matrix(0, ncol=6, nrow = n.counties)
phiWsave <- matrix(0, ncol=6, nrow = n.counties)
sigmasave <- matrix(0, ncol=6, nrow=n.counties)
gamma3save <- matrix(0, ncol=3, nrow=n.counties)
gamma4save <- matrix(0, ncol=3, nrow=n.counties)
waic <- matrix(0, ncol = 2, nrow = n.counties)
gelman <- vector('list', length = n.counties)
raftery <- vector('list', length = n.counties)
for (jj in 1:n.counties) {
thiscounty <- counties[jj]
#Select just one county
this <- dat %>%
subset(Recip_County==thiscounty) %>%
select(Date, category, prev_log_new_death, Administered_Dose1_Pop_Pct.x, log_new_death,
new_vax_this_week, new_cases_per_100k)
###############
# Create data for Nimble Model
# Note: Using rev() bc data appear to be in reverse time order so I'm putting them back in chronological order
z <- rev(this$category)
x1 <- rev(this$prev_log_new_death)
x2 <- rev(this$Administered_Dose1_Pop_Pct.x)
x2[1] <- 0 #no new vaccinations before the first date
n <- length(z)
y <- rev(this$new_cases_per_100k)
###############
#Nimble Ordinal Model
codeOrd <- nimbleCode({
beta1death ~ dnorm(0, sd = 200)
beta2death ~ dnorm(0, sd = 200)
beta1vax ~ dnorm(0, sd = 200)
beta2vax ~ dnorm(0, sd = 200)
tau ~ dunif(5,n-5)
sigma ~ dgamma(1, .1)
alpha3 ~ dnorm(0,1)
alpha4 ~ dnorm(0,1)
gam[1] <- -9999999
gam[2] <- 0
gam[3] <- exp(alpha3)
gam[4] <- exp(alpha4) + gam[3]
gam[5] <- 9999999
phiU ~ dunif(0,20)
phiW ~ dunif(0,20)
phiV ~ dunif(0,20)
cholU[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiU))
U[1:n] ~ dmnorm(mu_zero[1:n], cholesky = cholU[1:n,1:n], prec_param = 1)
cholW[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiW))
cholV[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiV))
W[1:n] ~ dmnorm(mu_zero[1:n], cholesky=cholW[1:n,1:n], prec_param=1)
V[1:n] ~ dmnorm(mu_zero[1:n], cholesky=cholV[1:n,1:n], prec_param=1)
beta1deathstar <- beta1death / sigma
beta2deathstar <- beta2death / sigma
beta1vaxstar <- beta1vax / sigma
beta2vaxstar <- beta2vax / sigma
for(i in 1:n){
mu[i] <- U[i] + (beta1death * x1[i] + beta1vax*x2[i] + V[i]) * ((tau-i) + abs(tau-i)) / (2 * (tau-i)) +
(beta2death * x1[i] +beta2vax*x2[i] + W[i])* ((i-tau) + abs(i-tau)) / (2 * (i-tau))
z[i,] ~ dmulti(psi[i,1:4], size=1)
for(j in 1:4){
psi[i,j] <- iprobit((gam[j+1]-mu[i])/sigma) - iprobit((gam[j]-mu[i])/sigma)
}
}
})
#Setting Values
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
z2 <- matrix(0, nrow=n, ncol=4)
for(i in 1:n){
z2[i,z[i]] <- 1
}
constantsOrd <- list(n = n, x1 = x1,x2=x2, mu_zero = mu_zero)
dataOrd <- list(z = z2, distmat=distmat)
gaminit <- c(-2, 0, exp(0), exp(1) + exp(0),  5)
y1 <- runif(length(z), min=gaminit[z], max=gaminit[z+1])
xmat <- cbind(x1, x2)
betainit <- c(solve(t(xmat)%*%xmat)%*%t(xmat)%*%y1)
initsOrd <- list(beta1death = betainit[1], beta2death = betainit[1],
beta1vax=betainit[2], beta2vax=betainit[2], tau = n/2+.1,
sigma=1, alpha3 = 0, alpha4 = 1, phiU=1, phiW=1, phiV=1, U=mu_zero,
W=mu_zero, V=mu_zero)
modelOrd <- nimbleModel(codeOrd, constants = constantsOrd, data = dataOrd, inits = initsOrd)
#Compile Model, run MCMC
cmodelOrd = compileNimble(modelOrd)
mcmc.outOrd <- nimbleMCMC(code = codeOrd, constants = constantsOrd,
data = dataOrd, inits = initsOrd, nburnin=5000,
nchains = 2, niter = 100000,thin=5,
summary = TRUE,
monitors = c('beta1death', "beta2death", "beta1vax", "beta2vax",
"alpha3","alpha4", "tau", "phiU", "phiV", "phiW", "sigma",
"beta1deathstar", "beta2deathstar",
"beta1vaxstar", "beta2vaxstar",
"gam"),
samplesAsCodaMCMC = TRUE,
WAIC = TRUE)
#Model Summary
#mcmc.outOrd$summary
tausave[jj,1:3] <- mcmc.outOrd$summary$all.chains[20,c(1,4,5)]
beta1deathsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[4, c(1, 4, 5)]
beta2deathsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[8, c(1, 4, 5)]
beta1vaxsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[6, c(1, 4, 5)]
beta2vaxsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[10, c(1, 4, 5)]
phiUsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[16, c(1, 4, 5)]
phiVsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[17, c(1, 4, 5)]
phiWsave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[18, c(1, 4, 5)]
sigmasave[jj, 1:3] <- mcmc.outOrd$summary$all.chains[19, c(1, 4, 5)]
gam3save[jj, 1:3] <- mcmc.outOrd$summary$all.chains[13, c(1, 2, 3)]
gam4save[jj, 1:3] <- mcmc.outOrd$summary$all.chains[14, c(1, 2, 3)]
waic[jj, 1] <- mcmc.outOrd$WAIC$WAIC
gelman[[jj]][[1]] <- gelman.diag(mcmc.outOrd$samples)
raftery[[jj]][[1]] <- raftery.diag(mcmc.outOrd$samples)
###############################
# Compare the change point when we estimate with continuous response
codeCont <- nimbleCode({
beta1death ~ dnorm(0, sd = 200)
beta2death ~ dnorm(0, sd = 200)
beta1vax ~ dnorm(0, sd = 200)
beta2vax ~ dnorm(0, sd = 200)
tau ~ dunif(5,n-5)
sigma ~ dgamma(1, .1)
phiU ~ dunif(0,20)
phiW ~ dunif(0,20)
phiV ~ dunif(0,20)
cholU[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiU))
U[1:n] ~ dmnorm(mu_zero[1:n], cholesky = cholU[1:n,1:n], prec_param = 1)
cholW[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiW))
cholV[1:n,1:n] <- chol(exp(-distmat[1:n,1:n]/phiV))
W[1:n] ~ dmnorm(mu_zero[1:n], cholesky=cholW[1:n,1:n], prec_param=1)
V[1:n] ~ dmnorm(mu_zero[1:n], cholesky=cholV[1:n,1:n], prec_param=1)
for(i in 1:n){
mu[i] <- U[i] + (beta1death * x1[i] + beta1vax*x2[i] + V[i]) * ((tau-i) + abs(tau-i)) / (2 * (tau-i)) +
(beta2death * x1[i] +beta2vax*x2[i] + W[i])* ((i-tau) + abs(i-tau)) / (2 * (i-tau))
y[i] ~ dnorm(mu[i], sigma)
}
})
# Setting Values
mu_zero <- rep(0, n)
distmat <- as.matrix(dist(1:n))
constantsCont <- list(n = n, x1 = x1,x2=x2, mu_zero = mu_zero)
dataCont <- list(y = y, distmat=distmat)
xmat <- cbind(x1, x2)
betainit <- c(solve(t(xmat)%*%xmat)%*%t(xmat)%*%y)
initsCont <- list(beta1death = betainit[1], beta2death = betainit[1],
beta1vax=betainit[2], beta2vax=betainit[2], tau = n/2+.1,
sigma=1, phiU=1, phiW=1, phiV=1, U=mu_zero,
W=mu_zero, V=mu_zero)
modelCont <- nimbleModel(codeCont, constants = constantsCont, data = dataCont, inits = initsCont)
# Compile Model, run MCMC
cmodelCont = compileNimble(modelCont)
mcmc.outCont <- nimbleMCMC(code = codeCont, constants = constantsCont,
data = dataCont, inits = initsCont, nburnin=5000,
nchains = 2, niter = 100000,thin=5,
summary = TRUE,
monitors = c('beta1death', "beta2death", "beta1vax", "beta2vax",
"tau", "phiU", "phiV", "phiW", "sigma"),
samplesAsCodaMCMC = TRUE,
WAIC = TRUE)
# Model Summary
#mcmc.outCont$summary
tausave[jj,4:6] <- mcmc.outCont$summary$all.chains[9,c(1,4,5)]
beta1deathsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[1, c(1, 4, 5)]
beta2deathsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[3, c(1, 4, 5)]
beta1vaxsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[2, c(1, 4, 5)]
beta2vaxsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[4, c(1, 4, 5)]
phiUsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[5, c(1, 4, 5)]
phiVsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[6, c(1, 4, 5)]
phiWsave[jj, 4:6] <- mcmc.outCont$summary$all.chains[7, c(1, 4, 5)]
sigmasave[jj, 4:6] <- mcmc.outCont$summary$all.chains[8, c(1, 4, 5)]
waic[jj, 2] <- mcmc.outCont$WAIC$WAIC
gelman[[jj]][[2]] <- gelman.diag(mcmc.outCont$samples)
raftery[[jj]][[2]] <- raftery.diag(mcmc.outCont$samples)
print(paste("Finished:", jj))
}
# save(tausave, beta1deathsave, beta2deathsave, beta1vaxsave, beta2vaxsave,
#     phiUsave, phiVsave, phiWsave, sigmasave, gam3save, gam4save, waic, gelman, raftery,
#     counties, file="CurrentModel.Rdata")
